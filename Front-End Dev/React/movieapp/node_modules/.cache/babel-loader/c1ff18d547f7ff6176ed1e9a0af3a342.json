{"ast":null,"code":"var _jsxFileName = \"/Users/syukrirahiman/OneDrive - Singapore Management University/React/movieapp/src/Main.js\";\nimport React, { Component } from \"react\";\nimport heartIcon from \"../images/heart-icon.png\";\nimport { convertLatLngToObj } from \"../utility/helper\";\n\nconst _require = require(\"react-google-maps\"),\n      Marker = _require.Marker,\n      DirectionsRenderer = _require.DirectionsRenderer;\n\nclass DirectionRenderComponentAsync extends Component {\n  constructor(...args) {\n    super(...args);\n    this.state = {\n      directions: null,\n      wayPoints: null,\n      currentLocation: null\n    };\n    this.delayFactor = 0;\n\n    this.getDirectionsPromise = (startLoc, destinationLoc, wayPoints) => this.getDirections(startLoc, destinationLoc, wayPoints).then(response => {\n      if (response.status === window.google.maps.DirectionsStatus.OK) {\n        const wayPts = response.result.routes[0].overview_path.filter((elem, index) => {\n          return index % 10 === 0;\n        });\n        this.setState({\n          directions: response.result,\n          wayPoints: wayPts\n        });\n        this.setCurrentLocation(wayPts);\n      } else if (response.status === window.google.maps.DirectionsStatus.OVER_QUERY_LIMIT) {\n        this.delayFactor += 0.2;\n\n        if (this.delayFactor === 15) {\n          this.delayFactor = 0.2;\n        }\n\n        setTimeout(() => {\n          this.getDirectionsPromise(startLoc, destinationLoc, response.wayPoints);\n        }, this.delayFactor * 200);\n      } else {\n        console.error(\"error fetching directions \".concat(response.result));\n      }\n    });\n\n    this.setCurrentLocation = wayPoints => {\n      let count = 0;\n      let refreshIntervalId = setInterval(() => {\n        // console.log(\"wayPoints:\", wayPoints);\n        if (wayPoints) {\n          if (count <= wayPoints.length - 1) {\n            const currentLocation = convertLatLngToObj(wayPoints[count].lat(), wayPoints[count].lng());\n            this.setState({\n              currentLocation\n            });\n            const wayPts = [];\n            wayPts.push(currentLocation);\n            const startLoc = this.props.from.lat + \", \" + this.props.from.lng;\n            const destinationLoc = this.props.to.lat + \", \" + this.props.to.lng;\n            this.delayFactor = 0;\n            this.getDirectionsPromise(startLoc, destinationLoc, wayPts);\n            count++;\n          } else {\n            clearInterval(refreshIntervalId);\n          }\n        }\n      }, 1000);\n    };\n  }\n\n  componentDidMount() {\n    const startLoc = \"\".concat(this.props.from.lat, \", \").concat(this.props.from.lng);\n    const destinationLoc = \"\".concat(this.props.to.lat, \", \").concat(this.props.to.lng);\n    this.getDirectionsPromise(startLoc, destinationLoc, []);\n  }\n\n  async getDirections(startLoc, destinationLoc, wayPoints = []) {\n    return new Promise((resolve, reject) => {\n      const waypts = [];\n\n      if (wayPoints.length > 0) {\n        waypts.push({\n          location: new window.google.maps.LatLng(wayPoints[0].lat, wayPoints[0].lng),\n          stopover: true\n        });\n      }\n\n      const DirectionsService = new window.google.maps.DirectionsService();\n      DirectionsService.route({\n        origin: startLoc,\n        destination: destinationLoc,\n        waypoints: waypts,\n        optimizeWaypoints: true,\n        travelMode: window.google.maps.TravelMode.DRIVING\n      }, (result, status) => {\n        resolve({\n          status,\n          result,\n          wayPoints\n        });\n      });\n    });\n  }\n\n  render() {\n    let originMarker = null;\n    let destinationMarker = null;\n\n    if (this.state.directions && this.props.index) {\n      originMarker = React.createElement(Marker, {\n        defaultLabel: this.props.index.toString(),\n        defaultIcon: null,\n        position: {\n          lat: parseFloat(this.props.from.lat),\n          lng: parseFloat(this.props.from.lng)\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 109\n        },\n        __self: this\n      });\n      destinationMarker = React.createElement(Marker, {\n        label: this.props.index.toString(),\n        defaultIcon: null,\n        position: {\n          lat: parseFloat(this.props.to.lat),\n          lng: parseFloat(this.props.to.lng)\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 119\n        },\n        __self: this\n      });\n    }\n\n    return React.createElement(\"div\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 130\n      },\n      __self: this\n    }, originMarker, destinationMarker, this.state.currentLocation && React.createElement(Marker, {\n      defaultIcon: heartIcon,\n      position: {\n        lat: this.state.currentLocation.lat,\n        lng: this.state.currentLocation.lng\n      },\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 134\n      },\n      __self: this\n    }), this.state.directions && React.createElement(DirectionsRenderer, {\n      directions: this.state.directions,\n      options: {\n        polylineOptions: {\n          storkeColor: this.props.storkeColor,\n          strokeOpacity: 0.4,\n          strokeWeight: 4\n        },\n        preserveViewport: true,\n        suppressMarkers: true,\n        icon: {\n          scale: 3\n        }\n      },\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 143\n      },\n      __self: this\n    }));\n  }\n\n}\n\nexport default DirectionRenderComponentAsync;","map":{"version":3,"sources":["/Users/syukrirahiman/OneDrive - Singapore Management University/React/movieapp/src/Main.js"],"names":["React","Component","heartIcon","convertLatLngToObj","require","Marker","DirectionsRenderer","DirectionRenderComponentAsync","state","directions","wayPoints","currentLocation","delayFactor","getDirectionsPromise","startLoc","destinationLoc","getDirections","then","response","status","window","google","maps","DirectionsStatus","OK","wayPts","result","routes","overview_path","filter","elem","index","setState","setCurrentLocation","OVER_QUERY_LIMIT","setTimeout","console","error","count","refreshIntervalId","setInterval","length","lat","lng","push","props","from","to","clearInterval","componentDidMount","Promise","resolve","reject","waypts","location","LatLng","stopover","DirectionsService","route","origin","destination","waypoints","optimizeWaypoints","travelMode","TravelMode","DRIVING","render","originMarker","destinationMarker","toString","parseFloat","polylineOptions","storkeColor","strokeOpacity","strokeWeight","preserveViewport","suppressMarkers","icon","scale"],"mappings":"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","sourcesContent":["import React, { Component } from \"react\";\r\nimport heartIcon from \"../images/heart-icon.png\";\r\nimport { convertLatLngToObj } from \"../utility/helper\";\r\nconst { Marker, DirectionsRenderer } = require(\"react-google-maps\");\r\n\r\nclass DirectionRenderComponentAsync extends Component {\r\n  state = {\r\n    directions: null,\r\n    wayPoints: null,\r\n    currentLocation: null\r\n  };\r\n  delayFactor = 0;\r\n\r\n  getDirectionsPromise = (startLoc, destinationLoc, wayPoints) =>\r\n    this.getDirections(startLoc, destinationLoc, wayPoints).then(response => {\r\n      if (response.status === window.google.maps.DirectionsStatus.OK) {\r\n        const wayPts = response.result.routes[0].overview_path.filter(\r\n          (elem, index) => {\r\n            return index % 10 === 0;\r\n          }\r\n        );\r\n        this.setState({\r\n          directions: response.result,\r\n          wayPoints: wayPts\r\n        });\r\n        this.setCurrentLocation(wayPts);\r\n      } else if (\r\n        response.status === window.google.maps.DirectionsStatus.OVER_QUERY_LIMIT\r\n      ) {\r\n        this.delayFactor += 0.2;\r\n        if (this.delayFactor === 15) {\r\n          this.delayFactor = 0.2;\r\n        }\r\n        setTimeout(() => {\r\n          this.getDirectionsPromise(\r\n            startLoc,\r\n            destinationLoc,\r\n            response.wayPoints\r\n          );\r\n        }, this.delayFactor * 200);\r\n      } else {\r\n        console.error(`error fetching directions ${response.result}`);\r\n      }\r\n    });\r\n\r\n  componentDidMount() {\r\n    const startLoc = `${this.props.from.lat}, ${this.props.from.lng}`;\r\n    const destinationLoc = `${this.props.to.lat}, ${this.props.to.lng}`;\r\n    this.getDirectionsPromise(startLoc, destinationLoc, []);\r\n  }\r\n\r\n  async getDirections(startLoc, destinationLoc, wayPoints = []) {\r\n    return new Promise((resolve, reject) => {\r\n      const waypts = [];\r\n      if (wayPoints.length > 0) {\r\n        waypts.push({\r\n          location: new window.google.maps.LatLng(\r\n            wayPoints[0].lat,\r\n            wayPoints[0].lng\r\n          ),\r\n          stopover: true\r\n        });\r\n      }\r\n      const DirectionsService = new window.google.maps.DirectionsService();\r\n      DirectionsService.route(\r\n        {\r\n          origin: startLoc,\r\n          destination: destinationLoc,\r\n          waypoints: waypts,\r\n          optimizeWaypoints: true,\r\n          travelMode: window.google.maps.TravelMode.DRIVING\r\n        },\r\n        (result, status) => {\r\n          resolve({ status, result, wayPoints });\r\n        }\r\n      );\r\n    });\r\n  }\r\n\r\n  setCurrentLocation = wayPoints => {\r\n    let count = 0;\r\n    let refreshIntervalId = setInterval(() => {\r\n      // console.log(\"wayPoints:\", wayPoints);\r\n      if (wayPoints) {\r\n        if (count <= wayPoints.length - 1) {\r\n          const currentLocation = convertLatLngToObj(\r\n            wayPoints[count].lat(),\r\n            wayPoints[count].lng()\r\n          );\r\n          this.setState({ currentLocation });\r\n          const wayPts = [];\r\n          wayPts.push(currentLocation);\r\n          const startLoc = this.props.from.lat + \", \" + this.props.from.lng;\r\n          const destinationLoc = this.props.to.lat + \", \" + this.props.to.lng;\r\n          this.delayFactor = 0;\r\n          this.getDirectionsPromise(startLoc, destinationLoc, wayPts);\r\n          count++;\r\n        } else {\r\n          clearInterval(refreshIntervalId);\r\n        }\r\n      }\r\n    }, 1000);\r\n  };\r\n  render() {\r\n    let originMarker = null;\r\n    let destinationMarker = null;\r\n    if (this.state.directions && this.props.index) {\r\n      originMarker = (\r\n        <Marker\r\n          defaultLabel={this.props.index.toString()}\r\n          defaultIcon={null}\r\n          position={{\r\n            lat: parseFloat(this.props.from.lat),\r\n            lng: parseFloat(this.props.from.lng)\r\n          }}\r\n        />\r\n      );\r\n      destinationMarker = (\r\n        <Marker\r\n          label={this.props.index.toString()}\r\n          defaultIcon={null}\r\n          position={{\r\n            lat: parseFloat(this.props.to.lat),\r\n            lng: parseFloat(this.props.to.lng)\r\n          }}\r\n        />\r\n      );\r\n    }\r\n    return (\r\n      <div>\r\n        {originMarker}\r\n        {destinationMarker}\r\n        {this.state.currentLocation && (\r\n          <Marker\r\n            defaultIcon={heartIcon}\r\n            position={{\r\n              lat: this.state.currentLocation.lat,\r\n              lng: this.state.currentLocation.lng\r\n            }}\r\n          />\r\n        )}\r\n        {this.state.directions && (\r\n          <DirectionsRenderer\r\n            directions={this.state.directions}\r\n            options={{\r\n              polylineOptions: {\r\n                storkeColor: this.props.storkeColor,\r\n                strokeOpacity: 0.4,\r\n                strokeWeight: 4\r\n              },\r\n              preserveViewport: true,\r\n              suppressMarkers: true,\r\n              icon: { scale: 3 }\r\n            }}\r\n          />\r\n        )}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default DirectionRenderComponentAsync;"]},"metadata":{},"sourceType":"module"}